#include "databasemanager.h"
#include <QSqlQuery>
#include <QSqlError>
#include <QDebug>
#include <QCryptographicHash>
#include <QStandardPaths>
#include <QDir>
#include <QUuid>

DatabaseManager& DatabaseManager::instance()
{
    static DatabaseManager instance;
    return instance;
}

DatabaseManager::DatabaseManager(QObject *parent) : QObject(parent)
{
    // The actual database initialization is deferred to initDatabase()
    // to allow QApplication to be fully initialized first, especially for paths.
}

DatabaseManager::~DatabaseManager()
{
    if (m_db.isOpen()) {
        m_db.close();
    }
}

bool DatabaseManager::openDatabase()
{
    if (m_db.isOpen()) {
        return true;
    }

    m_db = QSqlDatabase::addDatabase("QSQLITE"); // Unique connection name is generated by Qt
    QString path = QStandardPaths::writableLocation(QStandardPaths::AppDataLocation);
    QDir dir(path);
    if (!dir.exists()) {
        dir.mkpath(".");
    }
    QString dbPath = "mypro.db";
    m_db.setDatabaseName(dbPath);

    qDebug() << "Database path:" << dbPath;

    if (!m_db.open()) {
        qWarning() << "DatabaseManager Error: Failed to connect to database:" << m_db.lastError().text();
        return false;
    }
    return true;
}

bool DatabaseManager::createUsersTable()
{
    if (!m_db.isOpen() && !openDatabase()) return false;

    QSqlQuery query(m_db);
    QString createTableQuery = R"(
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT UNIQUE NOT NULL,
            password_hash TEXT NOT NULL,
            salt TEXT NOT NULL
        );
    )";
    if (!query.exec(createTableQuery)) {
        qWarning() << "DatabaseManager Error: Failed to create users table:" << query.lastError().text();
        return false;
    }
    return true;
}

bool DatabaseManager::initDatabase()
{
    if (!openDatabase()) return false;
    if (!createUsersTable()) return false;
    return true;
}


QByteArray DatabaseManager::generateSalt()
{
    // Generate a reasonably strong salt
    return QUuid::createUuid().toByteArray();
}

QByteArray DatabaseManager::hashPassword(const QString& password, const QByteArray& salt)
{
    QByteArray saltedPassword = salt + password.toUtf8();
    return QCryptographicHash::hash(saltedPassword, QCryptographicHash::Sha256).toHex();
}

bool DatabaseManager::userExists(const QString& username)
{
    if (!m_db.isOpen() && !openDatabase()) return false;

    QSqlQuery query(m_db);
    query.prepare("SELECT username FROM users WHERE username = :username");
    query.bindValue(":username", username);
    if (query.exec() && query.next()) {
        return true;
    }
    if (query.lastError().isValid()) {
         qWarning() << "DatabaseManager Error (userExists):" << query.lastError().text();
    }
    return false;
}

QVariantMap DatabaseManager::getUserCredentials(const QString& username)
{
    QVariantMap credentials;
    if (!m_db.isOpen() && !openDatabase()) return credentials;

    QSqlQuery query(m_db);
    query.prepare("SELECT password_hash, salt FROM users WHERE username = :username");
    query.bindValue(":username", username);

    if (query.exec() && query.next()) {
        credentials["password_hash"] = query.value("password_hash").toByteArray();
        credentials["salt"] = query.value("salt").toByteArray();
    } else if (query.lastError().isValid()) {
        qWarning() << "DatabaseManager Error (getUserCredentials):" << query.lastError().text();
    }
    return credentials;
}

bool DatabaseManager::createDeveloperUser(const QString& password)
{
    const QString username = "developer"; // Fixed username for the developer
    if (userExists(username)) {
        qWarning() << "DatabaseManager: Developer user already exists.";
        // Optionally, you could update the password here if needed,
        // but `changePassword` is better suited for that.
        return true; // Or false if you consider this an error condition
    }

    if (!m_db.isOpen() && !openDatabase()) return false;

    QByteArray salt = generateSalt();
    QByteArray hashedPassword = hashPassword(password, salt);

    QSqlQuery query(m_db);
    query.prepare("INSERT INTO users (username, password_hash, salt) VALUES (:username, :password_hash, :salt)");
    query.bindValue(":username", username);
    query.bindValue(":password_hash", hashedPassword);
    query.bindValue(":salt", salt);

    if (!query.exec()) {
        qWarning() << "DatabaseManager Error: Failed to create developer user:" << query.lastError().text();
        return false;
    }
    qDebug() << "DatabaseManager: Developer user created successfully.";
    return true;
}

bool DatabaseManager::verifyPassword(const QString& username, const QString& password)
{
    QVariantMap credentials = getUserCredentials(username);
    if (credentials.isEmpty()) {
        return false; // User not found
    }

    QByteArray salt = credentials["salt"].toByteArray();
    QByteArray storedHash = credentials["password_hash"].toByteArray();
    QByteArray inputHash = hashPassword(password, salt);

    return inputHash == storedHash;
}

bool DatabaseManager::changePassword(const QString& username, const QString& oldPassword, const QString& newPassword)
{
    if (!verifyPassword(username, oldPassword)) {
        qWarning() << "DatabaseManager: Old password verification failed for" << username;
        return false;
    }

    if (!m_db.isOpen() && !openDatabase()) return false;

    QByteArray newSalt = generateSalt();
    QByteArray newHashedPassword = hashPassword(newPassword, newSalt);

    QSqlQuery query(m_db);
    query.prepare("UPDATE users SET password_hash = :password_hash, salt = :salt WHERE username = :username");
    query.bindValue(":password_hash", newHashedPassword);
    query.bindValue(":salt", newSalt);
    query.bindValue(":username", username);

    if (!query.exec()) {
        qWarning() << "DatabaseManager Error: Failed to change password for" << username << ":" << query.lastError().text();
        return false;
    }
    qDebug() << "DatabaseManager: Password changed successfully for" << username;
    return true;
}

void DatabaseManager::close() {
    if (m_db.isOpen()) {
        m_db.close();
    }
}
